# 8. 인덱스

## 8-1. 디스크 읽기 방식

데이터베이스의 성능 튜닝은 **디스크 I/O를 줄이는 것**이 관건일 때가 많다.

### 8-1-1. HDD vs SSD

| 구분 | 순차 I/O | 랜덤 I/O |
|------|----------|----------|
| **HDD** | 빠름 | 느림 (헤드 이동 필요) |
| **SSD** | HDD와 비슷 | **훨씬 빠름** ✅ |

> 💡 **DBMS용 스토리지로 SSD가 최적인 이유**  
> 데이터베이스 서버는 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이기 때문

### 8-1-2. 랜덤 I/O vs 순차 I/O

디스크 성능은 **헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐**에 의해 결정된다.

| I/O 방식 | 특징 | 사용 예 |
|----------|------|---------|
| **순차 I/O** | 연속된 데이터를 한 번에 읽음 | 풀 테이블 스캔 |
| **랜덤 I/O** | 여러 위치에서 데이터를 읽음 (부하 큼) | 인덱스 레인지 스캔 |

> 🎯 **쿼리 튜닝의 목적**  
> 랜덤 I/O 자체를 줄이는 것 = 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것

### 💡 참고: 언제 풀 테이블 스캔이 유리한가?

큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스 대신 **풀 테이블 스캔**을 유도하기도 한다. 순차 I/O가 랜덤 I/O보다 훨씬 많은 레코드를 읽어올 수 있기 때문이다.

- **OLTP** (웹 서비스): 인덱스 활용이 유리
- **데이터 웨어하우스/통계**: 풀 테이블 스캔이 유리할 수 있음

---

## 8-2. 인덱스란?

인덱스는 **칼럼의 값과 레코드가 저장된 주소를 키-값 쌍(Key-Value pair)으로 저장**한 자료 구조다.

### 자료 구조 비교

| 자료 구조 | 특징 | 대응 |
|-----------|------|------|
| **SortedList** | 항상 정렬된 상태 유지 | DBMS 인덱스 |
| **ArrayList** | 저장 순서 그대로 유지 | 데이터 파일 |

### SortedList (인덱스)의 장단점

| 장점 | 단점 |
|------|------|
| 정렬되어 있어 **SELECT가 빠름** | INSERT, UPDATE, DELETE 시 정렬 비용 발생 |

> ⚠️ **주의**  
> WHERE 조건절에 사용되는 모든 칼럼을 인덱스로 생성하면 저장 성능이 떨어지고 인덱스 크기가 비대해져 역효과 발생

### 인덱스의 분류

#### 역할별 구분

| 구분 | 설명 |
|------|------|
| **프라이머리 키 (PK)** | 레코드를 대표하는 식별자, NULL/중복 불가 |
| **세컨더리 인덱스** | PK를 제외한 모든 인덱스 (유니크 인덱스 포함) |

#### 알고리즘별 구분

| 알고리즘 | 특징 | 사용처 |
|----------|------|--------|
| **B-Tree** | 원래 값으로 인덱싱, 범위 검색 가능 | 가장 일반적 |
| **Hash** | 해시값으로 인덱싱, 매우 빠른 검색 | 동등 비교만 가능, 메모리 DB |

---

## 8-3. B-Tree 인덱스

가장 일반적으로 사용되는 인덱싱 알고리즘으로, DBMS에서는 주로 **B+-Tree** 또는 **B\*-Tree**가 사용된다.

### 8-3-1. 구조 및 특성

| 노드 | 역할 |
|------|------|
| **루트 노드** | 트리 최상위 노드 |
| **브랜치 노드** | 중간 노드 |
| **리프 노드** | 최하위 노드, 실제 데이터 레코드 주소 저장 |

> 💡 **중요**  
> 인덱스 키 값은 **정렬**되어 있지만, 데이터 파일의 레코드는 **임의의 순서**로 저장됨

### MyISAM vs InnoDB 인덱스 차이

| 스토리지 엔진 | 인덱스 저장 방식 | 특징 |
|--------------|------------------|------|
| **MyISAM** | 물리적 주소 (ROWID) | 레코드 위치 또는 오프셋 저장 |
| **InnoDB** | 논리적 주소 (PK 값) | 프라이머리 키가 주소 역할 |

### 8-3-2. B-Tree 인덱스 키 추가/삭제/변경/검색

#### 키 추가

1. 저장될 키 값으로 B-Tree상의 적절한 위치 검색
2. 리프 노드에 키 값과 레코드 주소 저장
3. 리프 노드가 꽉 차면 **노드 분리** 발생 (쓰기 비용 증가)

| 스토리지 엔진 | 키 추가 방식 |
|--------------|--------------|
| MyISAM / MEMORY | 즉시 인덱스에 반영 |
| InnoDB | 지연 처리 가능 (PK, 유니크는 즉시) |

#### 키 삭제

리프 노드에서 해당 키 값에 **삭제 마킹**만 수행 → 공간은 방치되거나 재활용

#### 키 변경

**삭제 후 새 키 값 추가** 형태로 처리 (두 단계)

#### 키 검색 (트리 탐색)

루트 노드 → 브랜치 노드 → 리프 노드 순으로 비교 작업 수행

> ⚠️ **B-Tree 인덱스 검색 조건**
> - 100% 일치 또는 **값의 앞부분(Left-most part)** 일치
> - 키 값에 변형이 가해지면 인덱스 사용 불가

### 8-3-3. B-Tree 인덱스 사용에 영향을 미치는 요소

#### 8-3-3-1. 인덱스 키 값의 크기

| 항목 | 기본값 | 비고 |
|------|--------|------|
| 인덱스 페이지 크기 | 16KB | 4KB~64KB 선택 가능 |
| 자식 노드 주소 영역 | 12바이트 | 평균값 |

> ⚠️ **키 값이 커지면?**
> - 디스크 읽기 횟수 증가
> - 버퍼 풀에 캐시할 수 있는 레코드 수 감소

#### 8-3-3-2. B-Tree 깊이

키 값 크기에 따른 저장 가능 레코드 수 (깊이 3 기준):

| 키 값 크기 | 저장 가능 레코드 |
|------------|------------------|
| 16바이트 | 최대 **2억 개** (585³) |
| 32바이트 | 최대 **5천만 개** (372³) |

#### 8-3-3-3. 선택도 (기수성, Cardinality)

**유니크한 값의 개수**를 의미하며, 선택도가 높을수록 검색 대상이 줄어들어 **빠르게 처리**된다.

> 💡 최대한 중복된 값을 저장하지 않는 것이 좋다

#### 8-3-3-4. 읽어야 하는 레코드의 건수

| 조건 | 권장 방식 |
|------|-----------|
| 전체의 **20~25% 이하** | 인덱스 사용 |
| 전체의 **20~25% 초과** | 풀 테이블 스캔 |

> 인덱스를 통해 레코드 1건 읽는 비용 ≈ 직접 읽는 비용의 **4~5배**

### 8-3-4. B-Tree 인덱스를 통한 데이터 읽기

#### 8-3-4-1. 인덱스 레인지 스캔

가장 대표적이고 빠른 접근 방식

```
1. 인덱스 탐색: 조건을 만족하는 시작 위치 찾기
2. 인덱스 스캔: 필요한 만큼 순차적으로 읽기
3. 레코드 읽기: 인덱스 키와 주소로 실제 레코드 가져오기
```

> 💡 **커버링 인덱스**: 3번 과정이 필요 없는 인덱스 (랜덤 읽기 감소, 성능 향상)

#### 8-3-4-2. 인덱스 풀 스캔

인덱스의 **처음부터 끝까지 모두 읽는** 방식

#### 8-3-4-3. 루스 인덱스 스캔

필요하지 않은 키 값은 **무시하고 건너뛰는** 방식

- GROUP BY 또는 MAX(), MIN() 함수 최적화에 사용

#### 8-3-4-4. 인덱스 스킵 스캔 (MySQL 8.0+)

칼럼 순서와 상관없이 인덱스 검색이 가능하게 해주는 최적화 기능

**단점:**
- 선행 칼럼의 유니크한 값 개수가 적어야 함
- 커버링 인덱스여야 함

### 8-3-5. 다중 칼럼 인덱스

인덱스 내 각 칼럼의 **위치(순서)가 매우 중요**하며, 순서에 따라 성능이 달라진다.

### 8-3-6. B-Tree 인덱스의 정렬 및 스캔 방향

#### 정렬 순서 혼합 인덱스 생성

```sql
CREATE INDEX ix_teamname_userscore 
ON employees (team_name ASC, user_score DESC);
```

#### 인덱스 스캔 방향

옵티마이저가 쿼리에 따라 **읽기 방향을 전환**하여 정렬 효과를 얻을 수 있다.

#### 내림차순 인덱스가 더 느린 이유

| 이유 | 설명 |
|------|------|
| 페이지 잠금 구조 | 정순 스캔에 최적화 |
| 레코드 링크 구조 | 단방향(정순)으로만 연결 |

> 💡 자주 사용되는 정렬 순서대로 인덱스를 생성하면 잠금 병목 완화에 도움

### 8-3-7. B-Tree 인덱스의 가용성과 효율성

#### 8-3-7-1. 비교 조건의 종류와 효율성

| 용어 | 설명 |
|------|------|
| **작업 범위 결정 조건** | 인덱스의 작업 범위를 결정하는 조건 |
| **체크 조건 (필터링)** | 범위를 줄이지 못하고 필터 역할만 하는 조건 |

> 🎯 **효율성 향상의 핵심**: 작업 범위 결정 조건을 잘 만드는 것

#### 8-3-7-2. 인덱스의 가용성

B-Tree 특징: **왼쪽 값 기준으로 오른쪽 값이 정렬**

> ⚠️ **인덱스를 효율적으로 사용할 수 없는 예**
> - `LIKE '%mer'` (앞부분이 아닌 뒷부분 일치)
> - `INDEX(dept_no, emp_no)`에서 `emp_no`만 조건으로 사용

#### 8-3-7-3. 작업 범위 결정 조건으로 사용할 수 없는 경우

| 조건 | 예시 |
|------|------|
| NOT-EQUAL | `<>`, `NOT IN`, `NOT BETWEEN`, `IS NOT NULL` |
| 뒷부분 일치 LIKE | `LIKE '%abc'` |
| 인덱스 칼럼 변형 | `SUBSTRING(column, 1, 1) = 'X'` |
| 데이터 타입 불일치 | `char_column = 10` |
| 문자열 콜레이션 불일치 | `utf8_bin = euckr_bin` |

> 💡 **특이점**: MySQL은 NULL 값도 인덱스로 저장되므로 `IS NULL`은 작업 범위 결정 조건으로 사용 가능

#### 다중 칼럼 인덱스에서 작업 범위 결정 조건

```sql
INDEX ix_test (column_1, column_2, column_3, ..., column_n)
```

**작업 범위 결정 조건으로 사용하지 못하는 경우:**
- `column_1`에 대한 조건이 없는 경우
- `column_1`의 비교 조건이 인덱스 사용 불가 조건인 경우

**작업 범위 결정 조건으로 사용하는 경우 (2 < i < n):**
1. `column_1` ~ `column_(i-1)`까지 동등 비교 (`=` 또는 `IN`)
2. `column_i`에 대해: 동등 비교, 범위 비교 (`>`, `<`), 또는 좌측 일치 LIKE

---

## 8-4. R-Tree 인덱스

2차원 공간 데이터를 인덱싱하고 검색하는 목적의 **공간 인덱스**

### 8-4-1. 구조 및 특성

MySQL이 지원하는 공간 데이터 타입:

| 타입 | 설명 |
|------|------|
| **POINT** | 점 |
| **LINE** | 선 |
| **POLYGON** | 다각형 |
| **GEOMETRY** | 상위 3개의 슈퍼 타입 |

#### 핵심 개념

| 용어 | 설명 |
|------|------|
| **MBR** | Minimum Bounding Rectangle, 도형을 감싸는 최소 크기의 사각형 |
| **R-Tree** | MBR의 포함 관계를 B-Tree 형태로 구현한 인덱스 |

### 8-4-2. R-Tree 인덱스의 용도

- WGS84(GPS) 기준의 위도, 경도 좌표 저장
- 예: "현재 위치로부터 반경 5km 이내의 음식점 검색"

**인덱스를 효율적으로 사용하는 함수:**

| 함수 | 용도 |
|------|------|
| `ST_Contains()` | 포함 관계 비교 |
| `ST_Within()` | 포함 관계 비교 |

> ⚠️ `ST_Distance()`, `ST_Distance_Sphere()`는 공간 인덱스를 효율적으로 사용하지 못함  
> → `ST_Contains()`, `ST_Within()` 사용 후 distance 함수로 필터링 권장

---

## 8-5. 전문 검색 인덱스

문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 인덱스

### 8-5-1. 인덱스 알고리즘

#### 8-5-1-1. 어근 분석 알고리즘

**색인 작업:**

| 단계 | 설명 |
|------|------|
| **불용어 처리** | 검색에 가치 없는 단어 필터링 |
| **어근 분석 (Stemming)** | 검색어의 원형(뿌리) 찾기 |

> MeCab 플러그인: 일본어/한글 형태소 분석 지원 (완성도 높이려면 많은 노력 필요)

#### 8-5-1-2. n-gram 알고리즘

본문을 **n개의 글자씩 잘라서** 인덱싱하는 범용적인 방법

**처리 과정:**
1. 토큰 분리
2. 불용어 처리 (불용어와 동일하거나 포함하면 제거)
3. 최종 인덱스 등록

> 💡 불용어 확인: `information_schema.innodb_ft_default_stopword`

#### 8-5-1-3. 불용어 변경 및 삭제

**불용어 처리 무시 방법:**

| 방법 | 설정 |
|------|------|
| 모든 전문 검색 인덱스 | `ft_stopword_file = ''` (my.cnf) |
| InnoDB 테이블만 | `innodb_ft_enable_stopword = OFF` |

**사용자 정의 불용어 사용:**

| 방법 | 설정 |
|------|------|
| 파일로 저장 | `ft_stopword_file`에 파일 경로 등록 |
| 테이블로 저장 | `innodb_ft_server_stopword_table`에 테이블 설정 |

### 8-5-2. 전문 검색 인덱스의 가용성

**필수 조건:**
1. 쿼리 문장이 `MATCH ... AGAINST ...` 문법 사용
2. 테이블이 전문 인덱스 보유

```sql
-- 전문 검색 인덱스 생성
FULLTEXT KEY key_name (column_name) WITH PARSER ngram
```

---

## 8-6. 함수 기반 인덱스

칼럼의 값을 **변형해서 만들어진 값**에 대해 인덱스를 구축할 때 사용

### 8-6-1. 가상 칼럼을 이용한 인덱스 (MySQL 8.0+)

```sql
-- 가상 칼럼 생성
ALTER TABLE t ADD full_name VARCHAR(100) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL;

-- 가상 칼럼에 인덱스 생성
CREATE INDEX idx_full_name ON t (full_name);
```

> VIRTUAL, STORED 옵션 모두 인덱스 생성 가능

### 8-6-2. 함수를 이용한 인덱스

```sql
-- 테이블 구조 변경 없이 함수 직접 사용
CREATE INDEX idx_lower_name ON t ((LOWER(name)));
```

> ⚠️ **중요**: 조건절에 인덱스에 명시된 표현식이 **그대로** 사용되어야 함

---

## 8-7. 멀티 밸류 인덱스

JSON 데이터 타입을 위한 인덱스로, 키와 데이터 레코드가 **1:N 관계**

**활용 시 필수 함수:**

| 함수 | 용도 |
|------|------|
| `MEMBER OF()` | 배열에 값이 포함되어 있는지 확인 |
| `JSON_CONTAINS()` | JSON에 특정 값이 포함되어 있는지 확인 |
| `JSON_OVERLAPS()` | 두 JSON 배열이 겹치는지 확인 |

---

## 8-8. 클러스터링 인덱스

프라이머리 키 값이 비슷한 레코드끼리 **묶어서 저장**하는 것

> 🎯 **핵심**: 프라이머리 키 값에 의해 레코드의 **저장 위치가 결정**됨

### 특징

| 장점 | 단점 |
|------|------|
| PK로 검색할 때 **매우 빠름** | 저장/PK 변경이 상대적으로 느림 |

### 프라이머리 키가 없는 InnoDB 테이블

클러스터링 키 선택 우선순위:

1. 프라이머리 키
2. NOT NULL 옵션의 유니크 인덱스 중 첫 번째
3. 내부적으로 자동 생성된 유니크 칼럼

### 8-8-2. 세컨더리 인덱스에 미치는 영향

| 스토리지 엔진 | 인덱스 검색 방식 |
|--------------|------------------|
| **MyISAM** | 인덱스 → 레코드 주소 → 레코드 |
| **InnoDB** | 인덱스 → PK 값 → PK 인덱스 → 레코드 |

### 8-8-3. 클러스터링 인덱스의 장점과 단점

#### 장점

- PK로 검색할 때 **매우 빠름** (특히 범위 검색)
- 세컨더리 인덱스가 PK를 가지므로 **커버링 인덱스** 활용도 높음

#### 단점

- PK 크기가 크면 모든 인덱스 크기 증가
- 세컨더리 인덱스로 검색 시 PK 재검색 필요
- INSERT 시 저장 위치 결정으로 인한 성능 저하
- PK 변경 시 DELETE + INSERT 필요

### 8-8-4. 클러스터링 테이블 사용 시 주의사항

| 주의사항 | 권장 |
|----------|------|
| PK 크기 | 작게 유지 (세컨더리 인덱스 크기에 영향) |
| PK 선정 | 업무적으로 대표할 수 있는 칼럼 우선 |
| PK 필수 | 없으면 AUTO_INCREMENT라도 생성 |
| 인조 식별자 | 로그 테이블 등 INSERT 위주 테이블에 적합 |

---

## 8-9. 유니크 인덱스

인덱스라기보다는 **제약 조건**에 가깝다.

### 8-9-1. 유니크 인덱스 vs 일반 세컨더리 인덱스

#### 인덱스 읽기

| 구분 | 성능 |
|------|------|
| 유니크 인덱스 | 1건만 읽음 |
| 세컨더리 인덱스 | 1건 더 읽음 (CPU 비교 작업) |

> 💡 실질적인 성능 차이는 **거의 없음**

#### 인덱스 쓰기

| 구분 | 특징 |
|------|------|
| 유니크 인덱스 | 중복 체크 필요 → **더 느림** |
| 일반 인덱스 | 쓰기 지연 가능 |

> InnoDB는 쓰기 지연을 지원하지만, 유니크 인덱스는 중복 체크 때문에 **버퍼링 불가**

### 8-9-2. 유니크 인덱스 사용 시 주의사항

- 꼭 필요한 경우에만 생성
- 성능 향상을 위해 불필요하게 생성하지 않기
- 다른 인덱스와 **중복 생성 방지**

---

## 8-10. 외래키

InnoDB 스토리지 엔진에서만 생성 가능하며, 외래키 제약 설정 시 **자동으로 인덱스 생성**

### 외래키 관리 특징

1. 테이블의 **쓰기 잠금** 발생 시에만 잠금 경합 발생
2. 외래키와 **연관되지 않은 칼럼**의 변경은 잠금 경합 발생시키지 않음

### 8-10-1. 자식 테이블의 변경이 대기하는 경우

자식 테이블의 외래키 칼럼 변경 시:
- 부모 테이블의 해당 레코드 확인 필요
- 부모 테이블에 쓰기 잠금이 있으면 **대기**

> 외래키가 아닌 칼럼 변경은 잠금 확장 없음

### 8-10-2. 부모 테이블의 변경이 대기하는 경우

자식 테이블에 쓰기 잠금이 걸려있으면 **잠금 해제까지 대기** 후 작업 실행

---