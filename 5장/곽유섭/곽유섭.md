# 5. 트랜잭션 (Transaction)

## 📌 핵심 개념

### 트랜잭션 (Transaction)
작업의 완전성을 보장하여 데이터의 정합성을 유지하는 기능입니다. 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우 원 상태로 복구하여 **부분 업데이트(Partial Update)** 현상을 방지합니다.

### 잠금 (Lock)
동시성을 제어하는 기능으로, 여러 커넥션에서 동시에 동일한 자원(레코드, 테이블)을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 합니다.

### 격리 수준 (Isolation Level)
하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨입니다.

---

## 5-1. 트랜잭션

### 5-1-1. MySQL에서의 트랜잭션

트랜잭션은 하나의 논리적인 작업 셋에 쿼리가 하나든 여러 개든 관계없이, 해당 작업 셋이 **100% 적용(COMMIT)** 되거나 **아무것도 적용되지 않아야(ROLLBACK)** 함을 보장합니다.

### 5-1-2. 주의사항

> 💡 **트랜잭션의 범위를 최소화하라**
> 
> DBMS 커넥션과 마찬가지로 꼭 필요한 최소의 코드에만 트랜잭션을 적용해야 합니다.

#### ❌ 잘못된 예시
```
1) 처리 시작
   => 데이터베이스 커넥션 생성
   => 트랜잭션 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일 발송
9) 알림 메일 발송 이력을 DBMS에 저장
   <= 트랜잭션 종료(COMMIT)
   <= 데이터베이스 커넥션 반납
10) 처리 완료
```

#### ✅ 권장 예시
```
1) 처리 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
   => 데이터베이스 커넥션 생성
   => 트랜잭션 시작
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
   <= 트랜잭션 종료(COMMIT)
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일 발송
   => 트랜잭션 시작
9) 알림 메일 발송 이력을 DBMS에 저장
   <= 트랜잭션 종료(COMMIT)
   <= 데이터베이스 커넥션 반납
10) 처리 완료
```

---

## 5-2. MySQL 엔진의 잠금

MySQL의 잠금은 **스토리지 엔진 레벨**과 **MySQL 엔진 레벨**로 구분됩니다.

- **MySQL 엔진 잠금**: 모든 스토리지 엔진에 영향
- **스토리지 엔진 레벨 잠금**: 스토리지 엔진 간 상호 영향 없음

### MySQL 엔진의 4가지 잠금

#### 5-2-1. 글로벌 락 (Global Lock)

**획득 명령**
```sql
FLUSH TABLES WITH READ LOCK;
```

**특징**
- MySQL이 제공하는 잠금 중 범위가 가장 큼
- 한 세션에서 글로벌 락 획득 시, 다른 세션에서 SELECT를 제외한 모든 DDL/DML 문장이 대기 상태
- 작업 대상 테이블이나 데이터베이스가 달라도 MySQL 서버 전체에 적용

> ⚠️ **주의사항**
> 
> 글로벌 락 실행 시 서버의 모든 테이블을 닫고 잠금을 걸기 때문에, 최악의 경우 INSERT/UPDATE/DELETE 쿼리가 오랜 시간 대기할 수 있습니다. 웹 서비스 운영 중에는 최대한 지양해야 합니다.

**백업 락 (Backup Lock)** - MySQL 8.0 이후

InnoDB가 기본 스토리지 엔진이 되며 조금 더 가벼운 글로벌 락이 필요해져 도입되었습니다.
```sql
-- 획득
LOCK INSTANCE FOR BACKUP;

-- 해제
UNLOCK INSTANCE;
```

**백업 락 획득 시 변경 불가능한 작업**
- 데이터베이스 및 테이블 등 모든 객체 생성/변경/삭제
- REPAIR TABLE, OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

**용도**: 백업 중 스키마 변경이 일어나면 백업이 실패하므로, DDL 명령 실행 시 복제를 일시 중지하는 역할

---

#### 5-2-2. 테이블 락 (Table Lock)

개별 테이블 단위로 설정되는 잠금입니다.
```sql
-- 획득
LOCK TABLES table_name [ READ | WRITE ];

-- 해제
UNLOCK TABLES;
```

**묵시적 테이블 락**
- **MyISAM/MEMORY**: 데이터 변경 쿼리 실행 시 자동 발생
- **InnoDB**: 레코드 기반 잠금이므로 DDL 쿼리 실행 시에만 발생

---

#### 5-2-3. 네임드 락 (Named Lock)

사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금입니다.
```sql
-- 획득
SELECT GET_LOCK('lock_name', timeout);

-- 해제
SELECT RELEASE_LOCK('lock_name');
SELECT RELEASE_ALL_LOCKS();  -- 8.0 이후: 모든 락 해제
```

**유용한 상황**
- 여러 클라이언트가 상호 동기화를 처리해야 할 때
- 많은 레코드에 대해 복잡한 요건으로 변경하는 트랜잭션 상황
- MySQL 8.0 이후부터는 네임드 락을 중첩 사용 가능

---

#### 5-2-4. 메타데이터 락 (Metadata Lock)

데이터베이스 객체(테이블, 뷰 등)의 이름이나 구조를 변경하는 경우 자동으로 획득하는 잠금입니다.

---

## 5-3. InnoDB 스토리지 엔진 잠금

### 특징
- **레코드 기반 잠금 방식**으로 MyISAM보다 훨씬 뛰어난 동시성 처리 제공
- 이원화된 잠금 처리로 MySQL 명령을 이용한 접근이 까다로움

### 잠금 정보 진단 도구

**이전 버전**
- `lock_monitor` (innodb_lock_monitor 테이블 생성 후 잠금 정보 덤프)
- `SHOW ENGINE INNODB STATUS`

**최근 버전**
- `information_schema`: `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 테이블 조인
- `Performance Schema`를 이용한 모니터링

---

### 5-3-1. InnoDB 스토리지 엔진의 잠금 종류

> 💡 InnoDB의 잠금 정보는 매우 작은 공간으로 관리되므로, 레코드 락이 페이지 락이나 테이블 락으로 **레벨업되는 경우는 없습니다**.

#### 5-3-1-1. 레코드 락 (Record Lock)

**특징**
- 레코드 자체가 아닌 **인덱스의 레코드를 잠금**
- 인덱스가 없는 테이블도 자동 생성된 클러스터 인덱스를 이용해 잠금 설정
- 주로 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업 시 사용

#### 5-3-1-2. 갭 락 (Gap Lock)

**특징**
- 레코드 자체가 아닌 **레코드와 레코드 사이의 간격을 잠금**
- 새로운 레코드가 INSERT되는 것을 제어

#### 5-3-1-3. 넥스트 키 락 (Next-Key Lock)

**특징**
- **레코드 락 + 갭 락**을 합친 형태
- `REPEATABLE READ` 격리 수준 사용 시, 변경을 위해 검색하는 레코드에 적용

**목적**: 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버와 동일한 결과를 생성하도록 보장

> ⚠️ **주의사항**
> 
> 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 트랜잭션 대기가 자주 발생할 수 있습니다. 가능하다면 바이너리 로그 포맷을 ROW 형태로 변경하는 것이 좋습니다.
> 
> MySQL 8.0에서는 ROW 포맷의 바이너리 로그가 기본 설정입니다.

#### 5-3-1-4. 자동 증가 락 (Auto Increment Lock)

**특징**
- `AUTO_INCREMENT` 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT되는 경우 사용
- 중복되지 않고 저장된 순서대로 일련번호 값을 가지도록 보장
- **테이블 수준의 잠금**
- INSERT, REPLACE 쿼리에서만 필요

---

### 5-3-2. 인덱스와 잠금

MySQL InnoDB는 **인덱스를 잠그는 방식**으로 처리되기 때문에, 인덱스 설계에 따라 UPDATE 작업 성능이 크게 달라집니다.

---

### 5-3-3. 레코드 수준의 잠금 확인 및 해제

자주 사용되지 않는 레코드가 잠금 상태로 오래 유지되면 문제 해결에 많은 시간이 소요됩니다.

**MySQL 5.1 버전**
```sql
-- information_schema를 통한 확인
SELECT * FROM information_schema.INNODB_TRX;
SELECT * FROM information_schema.INNODB_LOCKS;
SELECT * FROM information_schema.INNODB_LOCK_WAITS;
```

**MySQL 8.0 버전**
```sql
-- performance_schema를 통한 확인
SELECT * FROM performance_schema.data_locks;
SELECT * FROM performance_schema.data_lock_waits;
```

---

## 5-4. MySQL의 격리 수준 (Isolation Level)

여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것입니다.

### 격리 수준별 부정합 문제

| 격리 수준 | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
|---|:---:|:---:|:---:|
| **READ UNCOMMITTED** | 발생 | 발생 | 발생 |
| **READ COMMITTED** | 없음 | 발생 | 발생 |
| **REPEATABLE READ** | 없음 | 없음 | 발생 (InnoDB는 없음) |
| **SERIALIZABLE** | 없음 | 없음 | 없음 |

> 📊 아래로 갈수록 트랜잭션 간 격리 정도가 높아지며, 동시 처리 성능은 떨어집니다.

**일반적인 사용**
- **Oracle 등**: `READ COMMITTED`
- **MySQL**: `REPEATABLE READ`

---

### 5-4-1. READ UNCOMMITTED

**특징**
- 각 트랜잭션의 변경 내용이 COMMIT/ROLLBACK 여부와 관계없이 다른 트랜잭션에서 보임
- **더티 리드(Dirty Read)** 허용

**더티 리드(Dirty Read)**
> 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상

⚠️ 표준에서는 트랜잭션 격리 수준으로 인정하지 않을 정도로 정합성 문제가 많습니다.

---

### 5-4-2. READ COMMITTED

**특징**
- Oracle DBMS의 기본 격리 수준
- 온라인 서비스에서 가장 많이 선택되는 격리 수준
- COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회 가능

**문제점: NON-REPEATABLE READ**
> 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때 항상 같은 결과를 가져와야 한다는 `REPEATABLE READ` 정합성에 어긋남

---

### 5-4-3. REPEATABLE READ

**특징**
- **MySQL InnoDB의 기본 격리 수준**
- 언두 영역에 백업된 레코드의 여러 버전 중 적절한 버전을 선택하여 조회
- MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 앞선 언두 영역의 데이터는 삭제 불가

**READ COMMITTED와의 차이**
> 언두 영역에 백업된 레코드의 여러 버전 중 몇 번째 이전 버전까지 찾아 들어가야 하느냐의 차이

**PHANTOM READ**
> 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상

**발생 원인**
- `SELECT ... FOR UPDATE` 쿼리는 레코드에 쓰기 잠금을 걸어야 하지만, 언두 레코드에는 잠금을 걸 수 없음
- 따라서 현재 데이터의 값을 가져오게 됨

---

### 5-4-4. SERIALIZABLE

**특징**
- 가장 단순하고 엄격한 격리 수준
- 동시 처리 성능이 가장 낮음
- **읽기 작업도 공유 잠금(읽기 잠금) 획득 필요**
- 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근 불가

---
