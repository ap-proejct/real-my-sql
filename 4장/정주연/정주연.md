MySQL 서버는 두 가지로 나눌 수 있다
- MySQL 엔진: 사람의 머리 역할을 담당한다
- 스토리지 엔진: 손과 발의 역할을 담당한다
  - 대표적으로 InnoDB와 MyISAM 엔진이 있다

## 1. MySQL 엔진 아키텍처

### 1. MySQL 엔진 아키텍처
<img src="./architecture.png" width="400">

#### 1). MySQL 엔진
- 커넥션 핸들러와 SQL 파서 및 전처리기, 옵티마이저가 중심을 이룬다
- 표준 SQL(ANSI SQL) 문법을 지원하기 때문에 타 DBMS와 호환되어 실행될 수 있다
1. 커넥션 핸들러, SQL 파서, 전처리기: 클라이언트로부터 접속 및 쿼리 요청을 처리한다
2. 옵티마이저: 쿼리의 최적화된 실행을 한다

#### 2). 스토리지 엔진
- SQL 문장을 분석하거나 최적화하고, 실제 데이터를 디스크에 저장하거나 읽어오는 부분을 전담한다
- 여러 개의 스토리지 엔진을 사용할 수 있다

#### 3). 핸들러 API
- MySQL 엔진 -> 스토리지 엔진에 요청하는 것을 핸들러 요청이라고 하고, 여기서 사용되는 API를 핸들러 API라고 한다
- 핸들러 API를 통해 얼마나 많은 데이터 작업이 있었는지 `SHOW GLOBAL STATUS LIKE HANDLER%` 명령으로 확인할 수 있다

## 2. MySQL 스레딩 구조
- MySQL 서버는 스레드 기반으로 작동하며 크게 **포그라운드**와 **백그라운드**로 구분할 수 있다
- 백그라운드 스레드이 개수는 MySQL 서버의 설정을 통해 변경할 수 있다

<img src="./thread.png" width="500">

### 1. 포그라운드 스레드(클라이언트 스레드)
- 최소 MySQL 서버에 접속된 클라이언트 수만큼 존재하며 주로 쿼리 문장을 처리한다
- 사용자가 작업을 마치면 해당 스레드는 **스레드 캐시**로 되돌아간다
  - 일정 개수 이상의 대기 중인 스레드가 있다면 스레드 캐시에 넣지 않고 스레드를 종료시킨다
  - 최대 스레드 개수는 `thread_cache_size` 시스템 변수로 설정한다
- 데이터는 MySQL 데이터 버퍼나 캐시로부터 가져오고 없는 경우 직접 디스크의 데이터에서 읽어와서 처리한다

>MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만\
InnoDB 테이블은 쓰기 작업은 백그라운드 스레드가 처리한다

### 2. 백그라운드 스레드
- InnoDB에서는 여러 가지 작업이 백그라운드에서 처리된다
1. 인서트 버퍼를 병합하는 스레드
2. 로그를 디스크로 기록하는 스레드
3. InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
4. 데이터를 버퍼로 읽어 오는 스레드
5. 잠금이나 데드락을 모니터링하는 스레드

>- 5.5 버전부터는 데이터 쓰기 스레드와 읽기 스레드의 개수를 2개 이상 지정할 수 있다
>- 읽기 작업은 주로 클라이언트 스레드로 처리되기 때문에 많이 설정할 필요는 없지만 쓰기 스레드는 많은 작업을 백그라운드에서 처리되기 때문에 내장 디스크는 2~4 정도, DAS나 SAN같은 스토리지를 이용할 때는 충분히 설정하는 것이 좋다
>- InnoDB는 지연(버퍼링)쓰기가 가능하지만 MyISAM은 쓰기 버퍼링 기능을 사용할 수 없다

### 3. 메모리 할당 및 사용 구조
- 메모리 공간은 크게 두 개로 구분할 수 있다

<img src="./memory.png" width="500">

#### 1). 글로벌 메모리 영역
- MySQL 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당받는다
- 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다
- 필요에 따라 2개이상 메모리 공간을 할당받을 수 있지만 모든 스레드에 의해 공유된다
- 대표적인 글로벌 메모리 영역
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDB 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버퍼

#### 2). 로컬 메모리 영역
- 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다
- 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 **세션 메모리 영역**이라고도 표현한다
- 독립적으로 할당되며 쿼리의 용도별로 공간이 할당되고 필요하지 않을 경우 할당조차 하지 않을 수 있다
- 대표적인 로컬 메모리 영역
  - 커넥션 버퍼
  - 정렬(소트) 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

### 4. 플러그인 스토리지 엔진 모델
- 스토리지 엔진뿐만 아니라 전문 검색 엔진을 위한 검색어 파서, 인증 등도 모두 플러그인으로 구현되어 제공된다
- 사용자가 직접 커스터마이징도 가능하다
- `SHOW PLUGIN` 명령으로 설치되어 있는 플러그인을 확인할 수 있다
- 단점
  - 플러그인은 오직 MySQL 서버와 인터페이스 할 수 있고, 플러그인끼리는 통신할 수 없다
  - 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않다
  - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어렵다

<img src="./memory.png" width="500">

#### 1. 처리 영역
- 거의 대부분의 작업이 MySQL 엔진에서 처리되고, `데이터 읽기/쓰기`작업만 스토리지 엔진에 의해 처리된다
- 서버 상태변수를 보면 `Handler_`로 시작되는 게 많은데 이는 MySQL 엔진이 각 스토리지 엔진에게 보낸 명령이라고 보면 된다
- 실질적인 `Group By`, `Order By` 등 복잡한 처리는 쿼리 실행기에서 처리된다

<img src="./process.png" width="700">

### 5. 컴포넌트
- 8.0 부터는 플러그인의 단점을 보완 및 대체하기 위해 컴포넌트 아키텍처가 지원된다
- `INSTALL COMPONENT 'file://component_validate_password'`으로 컴포넌트를 설치한다
- `SELECT * FROM mysql.component`를 통해 컴포넌트를 확인할 수 있다

### 6. 쿼리 실행 구조
<img src="./query_process.png" width="500">

#### 1). 쿼리 파서
- 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어낸다
- 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달한다

#### 2). 전처리기
- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다
- 각 토큰을 테이블 이름이나 칼럼 이름 또는 내장 함수와 같은 개체를 매핑해 존재 여부와 접근 권한등을 확인한다

#### 3). 옵티마이저
- 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당한다
- 가장 중요한 역할로 옵티마이저가 더 나은 선택할 수 있도록 유도를 해야 최적화가 좋아진다

#### 4). 실행 엔진
- 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다
- 즉 결과를 가지고 핸들러에게 요청한다고 보면 된다
```
1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 다시 읽어오라고 핸들러에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김
```
#### 5). 핸들러(스토리지 엔진)
- 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할을 담당한다
- 핸들러는 스토리지 엔진을 의미한다

### 8. 쿼리 캐시
- 8.0으로 올라가면서 쿼리 캐시는 완전히 삭제되었다

### 9. 스레드 풀
- 엔터프라이즈 에디션만 스레드풀을 지원한다
- 커뮤니티에서도 쓰고 싶다면 Perconda Server에서 스레드풀 플러그인 라이브러리를 설치하면 된다
  - 해당 플러그인은 선순위 큐와 후순위 큐를 이용해 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공한다

### 10. 트랜잭션 지원 메타데이터
- 메타데이터(데이터 딕셔너리): 테이블의 구조 정보와 스토어드 프로그램 등의 정보이다
- 5.7버전까지는 FRM, TRN 등으로 관리했지만 트랜잭션을 지원하지 않기 때문에 비정상적으로 종료되면 데이터가 깨졌었다
- 8.0 버전부터는 관련 정보를 모두 InnoDB의 테이블에 저장되도록 개선하고, MySQL 서버가 작동하는 데 기본적으로 필요한 테이블(시스템 테이블)을 InnoDB 엔진을 사용하고 `mysql.ibd`라는 이름의 테이블 스페이스에 저장된다
- 하지만 InnoDB가 아닌 MyISAM 같은 엔진은 메타정보를 저장할 곳이 필요하고 이를 SDI 파일을 사용한다
- InnoDB 스키마정보도 SDI 파일로 변환할 수 있고, `show tables` 명령으로 확인할 수 없었던 데이터를 구조를 알 수 있다

## 2. InnoDB 스토리지 엔진 아키텍처
<img src="./inno_db_architecture.png" width="500">

### 1. 프라이머리 키에 의한 클러스터링
- 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다
  - 즉 프라미러 키 값의 순서대로 디스크에 저장된다
- 모든 세컨더리 인덱스는 프라이머리 키 값을 논리적인 주소로 사용한다
- 프라이머리 키가 클러스터링 인덱스이기 때문에 다른 인덱스보다 빨리 처리도리 수 있다
> MyISAM 스토리지 엔진은 클러스터링 키를 지원하지 않고, 모든 인덱스가 물리적인 레코드의 주소 값을 가진다

### 2. 외래 키 지원
- InnoDB에서만 지원하는 기능으로 부모 테이블이나 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하다
- 사용 시 복잡해지기 때문에 운영에서는 잘 사용하지 않는다
- `SET foreign_key_checks=OFF`로 외래 키 체크를 멈출 수 있고 다시 실행시켜야 외래키 체크가 가능하다
  - 비활성화시 부모 테이블에 대한 작업(CASCADE)도 무시하게 된다

### 3. MVCC(Multi Version Concurrency Control)
- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기 제공이다
- 언두 로그(Undo Log)를 이용해 이 기능을 제공한다
- 멀티버전이라 함은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리되는 의미이다

<img src="./mvcc.png" width="500">

```
- UPDATE 문을 실행되면 커밋 여부와 상관없이 버퍼 풀은 `서울`로 업데이트 된다
- 커밋 전에 조회를 하게 되면 READ_COMMITED 이상의 격리수준에서는 언두 영역의 데이터를 반환한다
- 즉 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터를 보여지는지 상황에 따라 달리즈는 구조다
- 롤백을 실행하면 언두 영역에 있는 데이터를 InnoDB 버퍼풀로 다시 복구하고 이 언두영역을 필요로 하는 트랜잭션이 없을 경우 삭제한다
```

### 4. 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
- InnoDB는 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다


